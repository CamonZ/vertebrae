//! ID generation for Vertebrae tasks
//!
//! Generates unique 6-character alphanumeric identifiers using SHA256
//! hashing of title, timestamp, and random bytes.

use rand::Rng;
use sha2::{Digest, Sha256};
use std::time::{SystemTime, UNIX_EPOCH};

/// Length of generated task IDs
pub const ID_LENGTH: usize = 6;

/// Maximum number of collision retry attempts
const MAX_RETRIES: u32 = 100;

/// Generate a unique 6-character task ID.
///
/// The ID is generated by hashing:
/// - The task title
/// - Current timestamp (nanoseconds since UNIX epoch)
/// - Random bytes
///
/// The first 6 characters of the hex-encoded SHA256 hash are returned.
///
/// # Arguments
///
/// * `title` - The task title to incorporate into the hash
///
/// # Returns
///
/// A 6-character lowercase hexadecimal string.
#[allow(dead_code)] // Used in tests
pub fn generate_id(title: &str) -> String {
    generate_id_with_salt(title, 0)
}

/// Generate a unique ID with an additional salt value for collision retry.
///
/// # Arguments
///
/// * `title` - The task title
/// * `salt` - Additional salt for collision retries
fn generate_id_with_salt(title: &str, salt: u32) -> String {
    let mut hasher = Sha256::new();

    // Add title
    hasher.update(title.as_bytes());

    // Add timestamp
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_nanos();
    hasher.update(timestamp.to_le_bytes());

    // Add random bytes
    let random_bytes: [u8; 16] = rand::rng().random();
    hasher.update(random_bytes);

    // Add salt for retries
    hasher.update(salt.to_le_bytes());

    // Get hash and take first 6 hex characters
    let result = hasher.finalize();
    hex_encode_first_n(&result, ID_LENGTH)
}

/// Encode the first N characters as lowercase hex.
fn hex_encode_first_n(bytes: &[u8], n: usize) -> String {
    // Each byte becomes 2 hex chars, so we need n/2 bytes (rounded up)
    let bytes_needed = n.div_ceil(2);
    let hex: String = bytes
        .iter()
        .take(bytes_needed)
        .map(|b| format!("{:02x}", b))
        .collect();
    hex.chars().take(n).collect()
}

/// ID generator with collision detection support.
///
/// Provides an iterator-like interface for generating IDs with automatic
/// retry on collision.
pub struct IdGenerator<'a> {
    title: &'a str,
    attempt: u32,
}

impl<'a> IdGenerator<'a> {
    /// Create a new ID generator for the given title.
    pub fn new(title: &'a str) -> Self {
        Self { title, attempt: 0 }
    }

    /// Generate the next ID candidate.
    ///
    /// Returns `Some(id)` if under the retry limit, `None` if exhausted.
    pub fn next_id(&mut self) -> Option<String> {
        if self.attempt >= MAX_RETRIES {
            return None;
        }
        let id = generate_id_with_salt(self.title, self.attempt);
        self.attempt += 1;
        Some(id)
    }

    /// Get the current attempt number.
    #[allow(dead_code)] // Used in tests
    pub fn attempt(&self) -> u32 {
        self.attempt
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashSet;

    #[test]
    fn test_generate_id_returns_6_chars() {
        let id = generate_id("Test task");
        assert_eq!(id.len(), ID_LENGTH);
    }

    #[test]
    fn test_generate_id_is_lowercase_hex() {
        let id = generate_id("Test task");
        assert!(
            id.chars()
                .all(|c| c.is_ascii_hexdigit() && !c.is_uppercase())
        );
    }

    #[test]
    fn test_generate_id_is_alphanumeric() {
        let id = generate_id("Test task");
        assert!(id.chars().all(|c| c.is_alphanumeric()));
    }

    #[test]
    fn test_generate_id_different_for_same_title() {
        // Due to timestamp and random bytes, same title should produce different IDs
        let id1 = generate_id("Same title");
        let id2 = generate_id("Same title");
        // There's a tiny chance they could collide, but extremely unlikely
        assert_ne!(id1, id2, "IDs should differ due to timestamp/random");
    }

    #[test]
    fn test_generate_id_different_for_different_titles() {
        // Different titles should produce different IDs (with high probability)
        let id1 = generate_id("Title one");
        let id2 = generate_id("Title two");
        assert_ne!(id1, id2);
    }

    #[test]
    fn test_id_length_constant() {
        assert_eq!(ID_LENGTH, 6);
    }

    #[test]
    fn test_hex_encode_first_n() {
        let bytes = [0xab, 0xcd, 0xef, 0x12];
        assert_eq!(hex_encode_first_n(&bytes, 6), "abcdef");
        assert_eq!(hex_encode_first_n(&bytes, 4), "abcd");
        assert_eq!(hex_encode_first_n(&bytes, 2), "ab");
        assert_eq!(hex_encode_first_n(&bytes, 8), "abcdef12");
    }

    #[test]
    fn test_hex_encode_first_n_empty() {
        let bytes = [0xab, 0xcd];
        assert_eq!(hex_encode_first_n(&bytes, 0), "");
    }

    #[test]
    fn test_hex_encode_first_n_odd() {
        let bytes = [0xab, 0xcd];
        assert_eq!(hex_encode_first_n(&bytes, 3), "abc");
    }

    #[test]
    fn test_id_generator_new() {
        let generator = IdGenerator::new("Test");
        assert_eq!(generator.attempt(), 0);
    }

    #[test]
    fn test_id_generator_next_id() {
        let mut generator = IdGenerator::new("Test");
        let id = generator.next_id();
        assert!(id.is_some());
        assert_eq!(id.unwrap().len(), ID_LENGTH);
        assert_eq!(generator.attempt(), 1);
    }

    #[test]
    fn test_id_generator_multiple_ids_are_different() {
        let mut generator = IdGenerator::new("Test");
        let id1 = generator.next_id().unwrap();
        let id2 = generator.next_id().unwrap();
        let id3 = generator.next_id().unwrap();

        // All should be different (due to salt)
        assert_ne!(id1, id2);
        assert_ne!(id2, id3);
        assert_ne!(id1, id3);
    }

    #[test]
    fn test_id_generator_exhausts_after_max_retries() {
        let mut generator = IdGenerator::new("Test");

        // Generate MAX_RETRIES IDs
        for i in 0..MAX_RETRIES {
            let id = generator.next_id();
            assert!(id.is_some(), "Should have ID at attempt {}", i);
        }

        // Next should be None
        assert!(generator.next_id().is_none());
        assert_eq!(generator.attempt(), MAX_RETRIES);
    }

    #[test]
    fn test_id_generator_produces_unique_ids() {
        let mut generator = IdGenerator::new("Test unique");
        let mut ids = HashSet::new();

        // Generate 50 IDs and check they're all unique
        for _ in 0..50 {
            let id = generator.next_id().unwrap();
            assert!(ids.insert(id), "Generated duplicate ID");
        }
    }

    #[test]
    fn test_generate_id_with_empty_title() {
        let id = generate_id("");
        assert_eq!(id.len(), ID_LENGTH);
        assert!(id.chars().all(|c| c.is_ascii_hexdigit()));
    }

    #[test]
    fn test_generate_id_with_unicode_title() {
        let id = generate_id("Task with unicode");
        assert_eq!(id.len(), ID_LENGTH);
        assert!(id.chars().all(|c| c.is_ascii_hexdigit()));
    }

    #[test]
    fn test_generate_id_with_long_title() {
        let long_title = "A".repeat(10000);
        let id = generate_id(&long_title);
        assert_eq!(id.len(), ID_LENGTH);
        assert!(id.chars().all(|c| c.is_ascii_hexdigit()));
    }

    #[test]
    fn test_generate_id_with_special_chars() {
        let id = generate_id("Task with special chars: !@#$%^&*()");
        assert_eq!(id.len(), ID_LENGTH);
        assert!(id.chars().all(|c| c.is_ascii_hexdigit()));
    }

    #[test]
    fn test_id_generator_attempt_increments() {
        let mut generator = IdGenerator::new("Test");
        assert_eq!(generator.attempt(), 0);
        let _ = generator.next_id();
        assert_eq!(generator.attempt(), 1);
        let _ = generator.next_id();
        assert_eq!(generator.attempt(), 2);
    }

    #[test]
    fn test_multiple_generators_independent() {
        let mut generator1 = IdGenerator::new("Title 1");
        let mut generator2 = IdGenerator::new("Title 2");

        let id1a = generator1.next_id().unwrap();
        let id2a = generator2.next_id().unwrap();
        let id1b = generator1.next_id().unwrap();
        let id2b = generator2.next_id().unwrap();

        // All should be different
        let ids: HashSet<_> = [id1a, id2a, id1b, id2b].into_iter().collect();
        assert_eq!(ids.len(), 4, "All IDs should be unique");
    }
}
